Date: 6 May 2025



01. What is OOP / উদ্দেশ্য?
02. How OOP works ?  
03. Object (জিনিসপত্র) vs  Class(ব্লুপ্রিন্ট) |
04. কন্সট্রাক্টর(), ডিস্ট্রাক্টর(), অ্যাক্সেস মডিফায়ার, অ্যাবস্ট্রাক্ট ক্লাস এবং মেথডের উদ্দেশ্য |
05. ইন্টারফেসের উদ্দেশ্য |




========================== What is OOP? =============================
- একটি প্রোগ্রামিং প্যারাডাইম বা নকশা | - a style or way of structuring code.
4 Pillars of OOP

IPEA(Not IDEA) in Brief

১.  Inheritance:  এর মূল উদ্দেশ্য হলো- Reusibility, কোড পুনরায় ব্যবহার করা এবং ক্লাসগুলোর মধ্যে একটি শ্রেণিবদ্ধ সম্পর্ক তৈরি করা। এতে কোড বারবার লেখার দরকার হয় না।
                  একটি প্রক্রিয়া যার মাধ্যমে একটি নতুন ক্লাস (চাইল্ড বা ডেরাইভড ক্লাস) একটি বিদ্যমান ক্লাসের (প্যারেন্ট বা বেস ক্লাস) বৈশিষ্ট্য (ডেটা) এবং আচরণ (মেথড) উত্তরাধিকার সূত্রে পায়। 

২.  Polymorphism: এর মূল উদ্দেশ্য হলো- Flexibility & Extensibility একই নামের মেথড বিভিন্ন ধরণের অবজেক্টের জন্য, আলাদাভাবে যেন কাজ করতে পারে। 
                  Intelligence Inside Inheritance = Polymorphism(many forms)
                  উত্তরাধিকার সূত্রে প্রাপ্ত মেথডগুলোকে চাইল্ড ক্লাসে পুনরায় সংজ্ঞায়িত করার (ওভাররাইড করার) সুযোগ দেয় ।
                  Ex: Method Overloading/Compile-time(প্যারামিটারের সংখ্যা বা ডেটা টাইপ ভিন্ন), Method Overriding/Runtime(প্রয়োজন অনুযায়ী পুনরায় সংজ্ঞায়িত করে)
                  প্রায়শই ইনহেরিটেন্সের মাধ্যমে অর্জিত হয়, বিশেষ করে মেথড ওভাররাইডিংয়ের ক্ষেত্রে। 
                  উদাহরণস্বরূপ: যখন কোনো গুরুত্বপূর্ণ ঘটনা ঘটে (যেমন টাকা জমা, টাকা উত্তোলন, অ্যাকাউন্টে কম ব্যালেন্স, লোন পরিশোধের তারিখ), 
                               তখন গ্রাহককে ব্যাংকিং সফটওয়্যার বিভিন্ন মাধ্যমে নোটিফিকেশন পাঠাচ্ছে । 
                               এখানে "নোটিফিকেশন পাঠানো" একটি সাধারণ কাজ, 
                              কিন্তু কোন মাধ্যমে (যেমন এসএমএস, ইমেইল, অ্যাপ) নোটিফিকেশন পাঠানো হচ্ছে তার উপর নির্ভর করে কাজটি ভিন্নভাবে সম্পন্ন হয়।
                              -আমরা একটি মূল NotificationSender ক্লাস তৈরি করতে পারি, যেখানে একটি সাধারণ মেথড থাকবে sendNotification(message, recipient) (বিজ্ঞপ্তি পাঠান)।
                              এখন, বিভিন্ন মাধ্যমের জন্য আমরা এই NotificationSender ক্লাস থেকে ইনহেরিট করে আলাদা আলাদা ক্লাস তৈরি করতে পারি 
                              এবং sendNotification মেথডটিকে তাদের নিজস্ব উপায়ে বাস্তবায়ন করতে পারি

৩.  Encapsulation: এর মূল উদ্দেশ্য হলো- Access Control, ডেটা অ্যাক্সেস নিয়ন্ত্রণ করা । 
                  ডেটা ও মেথডকে একটি ইউনিটে বাঁধা । (প্রাইভেট) অ্যাক্সেস মডিফায়ার এর ব্যবহার ।
                  উদাহরণস্বরূপ: বাইরের সরাসরি অনিয়ন্ত্রিত প্রবেশ বন্ধ করা ।  এতে ডেটা সুরক্ষিত থাকে এবং সবকিছু গোছানো থাকে। 
                  একটা অবজেক্টের ভেতরের তথ্য (যেমন অ্যাকাউন্টের ব্যালেন্স) এবং সেই তথ্য ব্যবহারের নিয়ম (যেমন জমা দেওয়ার নিয়ম) একসাথে রাখা এবং বাইরের সরাসরি অনিয়ন্ত্রিত প্রবেশ বন্ধ করা। 
                 
৪.  Abstraction(ATM/PI): এর মূল উদ্দেশ্য হলো- Hide Complexitiy, ভেতরের জটিলতা লুকানো । শুধুমাত্র প্রয়োজনীয় তথ্য দেখানো । 
                  উদাহরণস্বরূপ: এটিএম কীভাবে আপনার অ্যাকাউন্ট থেকে টাকা বের করে, সেটা কিন্তু আপনি দেখেন না বা জানার দরকারও নেই। 
                               Data/Hide Access: Customer(Limited Access), Teller(most of access), Admin(All access)


===========================How OOP works? ====================================

১.  Account Types and Transactions (হিসাবের প্রকারভেদ ও লেনদেন): 
   একটি ব্যাংক বিভিন্ন ধরনের হিসাব সরবরাহ করে: সঞ্চয়ী হিসাব, চলতি হিসাব এবং স্থায়ী আমানত হিসাব। 
   প্রতিটি হিসাবের কিছু সাধারণ বৈশিষ্ট্য (যেমন হিসাব নম্বর ও ব্যালেন্স) থাকলেও কিছু স্বতন্ত্র আচরণ রয়েছে। 
       উদাহরণস্বরূপ, 
        সঞ্চয়ী হিসাবে সুদ জমা হয়, চলতি হিসাবে ওভারড্রাফ্টের সুবিধা থাকতে পারে এবং স্থায়ী আমানত হিসাবে একটি নির্দিষ্ট মেয়াদ এবং মেয়াদ শেষে সুদ প্রযোজ্য হয়। 
        এছাড়াও বিভিন্ন ধরনের লেনদেন রয়েছে: জমা, উত্তোলন, স্থানান্তর এবং সুদ প্রদান।
        -Many to One

প্রশ্ন ১: 
-এই বিভিন্ন ধরনের হিসাব এবং লেনদেনকে মডেল করার জন্য আপনি কীভাবে ইনহেরিটেন্স এবং সম্ভবত অ্যাবস্ট্রাক্ট ক্লাস ব্যবহার করে ক্লাস ডিজাইন করবেন? 
-মূল ক্লাস(গুলো) এবং ডেরাইভড ক্লাস(গুলো) কী হবে? 
-প্রতিটি হিসাব এবং লেনদেনের প্রকারের জন্য নির্দিষ্ট আচরণ এবং বৈশিষ্ট্যগুলো আপনি কীভাবে সামলাবেন?

২.  Customer Management and Account Linking(গ্রাহক ব্যবস্থাপনা ও হিসাবের সংযোগ): 
    একটি ব্যাংকের প্রতিটি গ্রাহকের বিভিন্ন ধরনের একাধিক হিসাব থাকতে পারে।
    সিস্টেমকে গ্রাহকের তথ্য (নাম, ঠিকানা, যোগাযোগের বিবরণ) পরিচালনা করতে এবং এই গ্রাহকদের তাদের নিজ নিজ হিসাবের সাথে সংযুক্ত করতে হবে।
    -One to Many

প্রশ্ন ২: 
-আপনি কীভাবে `Customer` (গ্রাহক) সত্তা এবং `Customer` ও বিভিন্ন `Account` (হিসাব) অবজেক্টের মধ্যে সম্পর্ক মডেল করবেন? 
-আপনি কোন ধরনের সম্পর্ক (যেমন অ্যাসোসিয়েশন, অ্যাগ্রিগেশন) ব্যবহার করবেন এবং আপনার কোডে এটি কীভাবে প্রয়োগ করবেন?

৩.  Transaction Processing and Logging (লেনদেন প্রক্রিয়াকরণ ও লগিং): 
    যখন কোনো লেনদেন (জমা, উত্তোলন, স্থানান্তর) ঘটে, তখন সিস্টেমকে লেনদেনের বিবরণ (সময়, পরিমাণ, জড়িত হিসাব, লেনদেনের প্রকার) রেকর্ড করতে হয়। 
    এই লেনদেন লগ নিরীক্ষণ এবং গ্রাহক পরিষেবার জন্য অত্যন্ত গুরুত্বপূর্ণ।

প্রশ্ন ৩: 
-বিভিন্ন ধরনের লেনদেন প্রক্রিয়াকরণের জন্য আপনি কীভাবে একটি সিস্টেম ডিজাইন করবেন? 
-প্রতিটি লেনদেন সঠিকভাবে রেকর্ড করা এবং সঠিক হিসাবের সাথে যুক্ত করা হয়েছে তা আপনি কীভাবে নিশ্চিত করবেন? 
-লেনদেন উপস্থাপনের জন্য ক্লাস ব্যবহার এবং সেগুলো কীভাবে `Account` অবজেক্টের সাথে যোগাযোগ করত হয় তা নিয়ে চিন্তা করুন।

৪.  Security and Access Control (নিরাপত্তা ও অ্যাক্সেস নিয়ন্ত্রণ): 
  ব্যাংকিং সিস্টেমের বিভিন্ন ব্যবহারকারীর বিভিন্ন স্তরের অ্যাক্সেস থাকে। 
    উদাহরণস্বরূপ, 
    একজন সাধারণ গ্রাহক কেবল তাদের নিজস্ব অ্যাকাউন্টের তথ্য অ্যাক্সেস করতে এবং তাদের অ্যাকাউন্টে লেনদেন করতে পারে। 
    একজন ব্যাংক টেলারের গ্রাহকের বিশদ বিবরণ দেখার এবং বিভিন্ন লেনদেন প্রক্রিয়া করার জন্য বৃহত্তর অ্যাক্সেস থাকতে পারে। 
    একজন সিস্টেম প্রশাসকের পুরো সিস্টেমের উপর সম্পূর্ণ নিয়ন্ত্রণ থাকতে পারে।

প্রশ্ন ৪: 
-আপনার ব্যাংকিং সিস্টেমে নিরাপত্তা এবং অ্যাক্সেস নিয়ন্ত্রণ প্রয়োগ করার জন্য আপনি কীভাবে এনক্যাপসুলেশন এবং সম্ভবত অন্যান্য OOP নীতি ব্যবহার করবেন? 
-সংবেদনশীল ডেটা এবং কার্যকারিতা সুরক্ষিত এবং শুধুমাত্র অনুমোদিত ব্যবহারকারী বা ভূমিকার কাছে অ্যাক্সেসযোগ্য তা আপনি কীভাবে নিশ্চিত করবেন?

এই বাস্তব-বিশ্বের ব্যাংকিং সমস্যাগুলো সমাধানের জন্য ক্লাস, অবজেক্ট, ইনহেরিটেন্স, এনক্যাপসুলেশন এবং পলিমরফিজম ব্যবহার করে আপনি কীভাবে আপনার কোড গঠন করবেন তা সাবধানে চিন্তা করুন। 
আপনার চিন্তাভাবনার প্রক্রিয়ায় আমি আপনাকে সাহায্য করার জন্য এখানে আছি। শুভকামনা!

========================= প্রশ্নগুলোর  সমাধান  ==============================

উত্তর ১:
* বেস ক্লাস: `Account` (হিসাব)। এতে সাধারণ বৈশিষ্ট্য থাকবে যেমন `accountNumber` (হিসাব নম্বর), `balance` (ব্যালেন্স) এবং সাধারণ মেথড যেমন `deposit()` (জমা), `withdraw()` (উত্তোলন)।
* ডেরাইভড ক্লাস: `SavingsAccount` (সঞ্চয়ী হিসাব), `CheckingAccount` (চলতি হিসাব), `FixedDepositAccount` (স্থায়ী আমানত হিসাব)। এগুলি `Account` থেকে ইনহেরিট করবে এবং তাদের নিজস্ব বৈশিষ্ট্য 
  (যেমন `interestRate` - সুদের হার, `overdraftLimit` - ওভারড্রাফ্টের সীমা, `maturityDate` - মেয়াদ পূর্তির তারিখ) এবং আচরণ (যেমন `calculateInterest()` - সুদ গণনা) যোগ করবে।
* লেনদেন: `Transaction` (লেনদেন) একটি অ্যাবস্ট্রাক্ট ক্লাস হতে পারে অথবা একটি সাধারণ ক্লাস হতে পারে 
  যার ডেরাইভড ক্লাস হবে `DepositTransaction` (জমা লেনদেন), `WithdrawalTransaction` (উত্তোলন লেনদেন), `TransferTransaction` (স্থানান্তর লেনদেন), `InterestPaymentTransaction` (সুদ প্রদান লেনদেন)। 
  প্রতিটি লেনদেন তার নিজস্ব বৈশিষ্ট্য (যেমন `timestamp` - সময়, `amount` - পরিমাণ, `involvedAccount` - জড়িত হিসাব) এবং প্রক্রিয়াকরণের নিয়ম ধারণ করবে।

সংক্ষিপ্ত সমাধান: ইনহেরিটেন্স ব্যবহার করে আমরা `Account` ক্লাসে সাধারণ বৈশিষ্ট্য রাখি এবং বিশেষায়িত হিসাবের জন্য ডেরাইভড ক্লাস তৈরি করি। লেনদেনের জন্যও একই পদ্ধতি ব্যবহার করা যেতে পারে।

উত্তর ২:
* আমরা একটি `Customer` ক্লাস তৈরি করব যার বৈশিষ্ট্য থাকবে যেমন `customerId` (গ্রাহক আইডি), `name` (নাম), `address` (ঠিকানা), `contactDetails` (যোগাযোগের বিবরণ)।
* গ্রাহকের সাথে তার একাধিক হিসাবের সম্পর্ক বোঝাতে আমরা একটি "হ্যাজ-এ" (has-a) সম্পর্ক ব্যবহার করব। 
  এর জন্য `Customer` ক্লাসের মধ্যে একটি লিস্ট বা অন্য কোনো কালেকশন থাকতে পারে যা সেই গ্রাহকের `Account` অবজেক্টগুলোর রেফারেন্স ধারণ করবে। 
  এটি অ্যাগ্রিগেশন ধরনের সম্পর্ক হবে, কারণ গ্রাহক মুছে গেলেও হিসাবগুলো থাকতে পারে।

সংক্ষিপ্ত সমাধান: `Customer` ক্লাসে গ্রাহকের তথ্য থাকবে এবং এর মধ্যে তাদের `Account` অবজেক্টগুলোর একটি তালিকা থাকবে।

উত্তর ৩:
* আমরা বিভিন্ন ধরনের লেনদেন (জমা, উত্তোলন, স্থানান্তর) প্রক্রিয়াকরণের জন্য আলাদা ক্লাস তৈরি করতে পারি 
  (যেমন `DepositProcessor`, `WithdrawalProcessor`, `TransferProcessor`) অথবা `Transaction` ক্লাসের মধ্যেই বিভিন্ন ধরনের লেনদেন হ্যান্ডেল করার লজিক রাখতে পারি।
* প্রতিটি লেনদেন সম্পন্ন হওয়ার পরে, একটি `Transaction` অবজেক্ট তৈরি করা হবে যা লেনদেনের সমস্ত বিবরণ ধারণ করবে। 
 এই `Transaction` অবজেক্টটি লেনদেন লগিংয়ের জন্য একটি ডেটাবেস বা ফাইলে সংরক্ষণ করা যেতে পারে। 
  `Account` অবজেক্টের সাথে লেনদেন যুক্ত করার জন্য `Transaction` অবজেক্টে সংশ্লিষ্ট `Account` অবজেক্টের রেফারেন্স রাখা যেতে পারে।

সংক্ষিপ্ত সমাধান: প্রতিটি লেনদেনের জন্য একটি `Transaction` অবজেক্ট তৈরি করে তার বিবরণ সংরক্ষণ করা হবে এবং এটি সংশ্লিষ্ট `Account` অবজেক্টের সাথে যুক্ত থাকবে।

উত্তর ৪:
* এনক্যাপসুলেশন: অ্যাকাউন্টের ব্যালেন্সের মতো সংবেদনশীল ডেটা সরাসরি অ্যাক্সেস করা থেকে রক্ষা করার জন্য আমরা প্রাইভেট অ্যাক্সেস মডিফায়ার ব্যবহার করব। 
  ব্যালেন্স পরিবর্তন বা দেখার জন্য পাবলিক মেথড (যেমন `deposit()`, `withdraw()`, `getBalance()`) সরবরাহ করা হবে, যেখানে অ্যাক্সেস নিয়ন্ত্রণের লজিক অন্তর্ভুক্ত থাকতে পারে।
* অ্যাক্সেস কন্ট্রোল: বিভিন্ন ব্যবহারকারীর ভূমিকার (যেমন গ্রাহক, টেলার, প্রশাসক) জন্য আলাদা ক্লাস বা ইন্টারফেস তৈরি করা যেতে পারে। 
  পলিমরফিজম ব্যবহার করে, একই নামের মেথড বিভিন্ন ভূমিকার জন্য আলাদা আচরণ প্রদান করতে পারে। এছাড়াও, আমরা রোল-ভিত্তিক অ্যাক্সেস কন্ট্রোল (RBAC) প্রয়োগ করতে পারি, 
  যেখানে প্রতিটি ভূমিকার নির্দিষ্ট অনুমতি থাকবে এবং লগইন করার পরে ব্যবহারকারীর ভূমিকা অনুযায়ী সিস্টেমের বিভিন্ন অংশে অ্যাক্সেস নিয়ন্ত্রিত হবে।

সংক্ষিপ্ত সমাধান: এনক্যাপসুলেশনের মাধ্যমে ডেটা সুরক্ষিত করা হবে এবং বিভিন্ন ব্যবহারকারীর ভূমিকার জন্য আলাদা অ্যাক্সেস লেভেল নির্ধারণ করা হবে।


=============================  Object (জিনিসপত্র) vs  Class(ব্লুপ্রিন্ট)===========================================================================

মনে করুন, আপনি ব্যাংকের একজন গ্রাহক, এবং আপনার কাছে বিভিন্ন ধরণের সেবা আছে।

১. Object (জিনিসপত্র):
ব্যাংকে আপনি যা কিছু দেখেন বা ব্যবহার করেন, সেগুলো এক একটা "জিনিস" বা অবজেক্ট। 
যেমন:
 আপনার অ্যাকাউন্ট (সঞ্চয়ী, চলতি, ঋণ)। প্রত্যেক অ্যাকাউন্টের কিছু তথ্য আছে (নাম, নম্বর, ব্যালেন্স) এবং কিছু কাজ আছে যা এটি করতে পারে (টাকা জমা দেওয়া, টাকা তোলা, ব্যালেন্স দেখানো)।
 এটিএম মেশিন। এর কিছু তথ্য আছে (অবস্থান, সিরিয়াল নম্বর) এবং কিছু কাজ আছে যা এটি করতে পারে (টাকা দেওয়া, ব্যালেন্স দেখানো)।
 ব্যাংকের কর্মকর্তা। তার কিছু তথ্য আছে (নাম, পদবি) এবং কিছু কাজ আছে যা তিনি করতে পারেন (অ্যাকাউন্ট খোলা, লোন দেওয়া)।

OOP-তে, আমরা এই বাস্তব জগতের "জিনিসগুলোকেই" আমাদের প্রোগ্রামের "অবজেক্ট" হিসেবে তৈরি করি।

২.Class(ব্লুপ্রিন্ট):
এখন ভাবুন, ব্যাংক যখন নতুন অ্যাকাউন্ট খোলে, তখন তারা একটা নির্দিষ্ট নিয়ম মেনে চলে। কোন কোন তথ্য লাগবে (নাম, ঠিকানা), আর কী কী কাজ এই অ্যাকাউন্ট করতে পারবে (জমা, তোলা)। এই নিয়মটা হলো ক্লাস।

 অ্যাকাউন্ট ক্লাস: এটা একটা ছাঁচ যার মাধ্যমে বিভিন্ন ধরণের অ্যাকাউন্ট তৈরি করা যায়। এই ক্লাসে বলা থাকে প্রত্যেক অ্যাকাউন্টের কী কী বৈশিষ্ট্য থাকবে (নাম, নম্বর, ব্যালেন্স) এবং কী কী কাজ সে করতে পারবে (জমা, তোলা)।
 এটিএম ক্লাস: এটা এটিএম তৈরির একটা ছাঁচ। এতে বলা থাকে প্রত্যেক এটিএমের কী কী বৈশিষ্ট্য থাকবে (অবস্থান) এবং কী কী কাজ সে করতে পারবে (টাকা দেওয়া, ব্যালেন্স দেখানো)।

==============================================================================================================================================================================
                                      কন্সট্রাক্টর(), ডিস্ট্রাক্টর(), অ্যাক্সেস মডিফায়ার, অ্যাবস্ট্রাক্ট ক্লাস এবং মেথডের উদ্দেশ্য 
==============================================================================================================================================================================

এখানে সফটওয়্যার ডিজাইন এবং অবজেক্ট-ওরিয়েন্টেড প্রোগ্রামিং (OOP) এর প্রেক্ষাপটে কন্সট্রাক্টর, ডিস্ট্রাক্টর, অ্যাক্সেস মডিফায়ার, অ্যাবস্ট্রাক্ট ক্লাস এবং মেথডের উদ্দেশ্যগুলো সংক্ষিপ্ত উদাহরণসহ আলোচনা করা হলো:

১. কন্সট্রাক্টর (Constructor):
 উদ্দেশ্য: 
 একটি কন্সট্রাক্টরের প্রধান উদ্দেশ্য হলো যখন কোনো ক্লাসের একটি অবজেক্ট (object) তৈরি করা হয়, তখন সেই অবজেক্টের প্রাথমিক অবস্থা (initial state) নির্ধারণ করা। 
 এর মাধ্যমে অবজেক্টের প্রয়োজনীয় প্রপার্টিজ (properties) বা অ্যাট্রিবিউটস (attributes) ইনিশিয়ালাইজ (initialize) করা হয় এবং প্রয়োজনে অন্যান্য প্রাথমিক কাজ সম্পন্ন করা হয়।

২. ডিস্ট্রাক্টর (Destructor):
 উদ্দেশ্য: 
 একটি ডিস্ট্রাক্টরের প্রধান উদ্দেশ্য হলো যখন কোনো অবজেক্ট ধ্বংস (destroy) হতে চলেছে (অর্থাৎ, মেমরি থেকে মুক্তি পেতে চলেছে), 
 তখন সেই অবজেক্টের সাথে যুক্ত রিসোর্স (resources) (যেমন ফাইল হ্যান্ডেল, নেটওয়ার্ক সংযোগ) মুক্ত (release) করা বা পরিষ্কার (cleanup) করা।
 

৩. অ্যাক্সেস মডিফায়ার (Access Modifiers) - `public`, `private`, `protected` (কিছু ভাষায়):
 উদ্দেশ্য:
  অ্যাক্সেস মডিফায়ারগুলো ক্লাসের মেম্বারদের (অ্যাট্রিবিউটস এবং মেথড) অ্যাক্সেসের সুযোগ (accessibility) নিয়ন্ত্রণ করে। 
  এর মাধ্যমে ইনক্যাপসুলেশন (encapsulation) এবং ডেটা হাইডিং (data hiding) অর্জন করা যায়, যা কোডের মডুলারিটি (modularity) এবং রক্ষণাবেক্ষণযোগ্যতা (maintainability) বাড়ায়।
     `public`: ক্লাসের বাইরে থেকেও অ্যাক্সেস করা যায়।
     `private`: শুধুমাত্র ক্লাসের ভেতরেই অ্যাক্সেস করা যায়।
     `protected`: ক্লাসের ভেতরে এবং এর উত্তরাধিকারী (child) ক্লাসে অ্যাক্সেস করা যায়।


৪. অ্যাবস্ট্রাক্ট ক্লাস (Abstract Classes) এবং মেথড (Methods):
 উদ্দেশ্য: 
 অ্যাবস্ট্রাক্ট ক্লাস এমন একটি ক্লাস যা সরাসরি ইনস্ট্যানশিয়েট (object তৈরি) করা যায় না। 
 এর মূল উদ্দেশ্য হলো এর উত্তরাধিকারী ক্লাসগুলোর জন্য একটি সাধারণ কাঠামো (common structure) এবং কিছু অবশ্যপালনীয় আচরণ (mandatory behavior) নির্ধারণ করে দেওয়া। 
 অ্যাবস্ট্রাক্ট মেথড হলো সেই মেথড যার শুধুমাত্র ঘোষণা (signature) থাকে, কোনো বাস্তবায়ন (implementation) থাকে না। উত্তরাধিকারী ক্লাসগুলোকে অবশ্যই এই অ্যাবস্ট্রাক্ট মেথডগুলোর বাস্তবায়ন প্রদান করতে হয়। 
 এটি পলিমরফিজম (polymorphism) অর্জনে সাহায্য করে।


৫. মেথড (Method):
 উদ্দেশ্য: 
 একটি মেথড হলো একটি ক্লাসের মধ্যে সংজ্ঞায়িত একটি ফাংশন (function) 
 যা ক্লাসের অবজেক্টের আচরণ (behavior) নির্ধারণ করে। মেথডগুলো অবজেক্টের ডেটা (অ্যাট্রিবিউটস) ম্যানিপুলেট করতে এবং নির্দিষ্ট কার্য সম্পাদন করতে ব্যবহৃত হয়।


সংক্ষেপে, এই ধারণাগুলো অবজেক্ট-ওরিয়েন্টেড প্রোগ্রামিং এর গুরুত্বপূর্ণ স্তম্ভ যা কোডের সংগঠন, ডেটা সুরক্ষা, পুনরায় ব্যবহারযোগ্যতা এবং নমনীয়তা বাড়াতে সাহায্য করে।


====================================================================================================================================
                                      ইন্টারফেসের উদ্দেশ্য 
====================================================================================================================================
সফটওয়্যার ডিজাইনে ইন্টারফেস (Interface) ব্যবহারের প্রধান উদ্দেশ্য হলো বিভিন্ন ক্লাসের মধ্যে একটি চুক্তি (contract) তৈরি করা, 
যা নির্ধারণ করে যে ঐ ক্লাসগুলোকে কী কী নির্দিষ্ট আচরণ (behavior) বা কার্যকারিতা (functionality) বাস্তবায়ন করতে হবে। ইন্টারফেস কোনো বাস্তবায়ন (implementation) প্রদান করে না, 
বরং এটি শুধুমাত্র মেথডগুলোর নাম (name), প্যারামিটার (parameters) এবং রিটার্ন টাইপ (return type) ঘোষণা করে।

ইন্টারফেসের মূল লক্ষ্যগুলো হলো:

চুক্তি নির্ধারণ (Defining a Contract): 
ইন্টারফেস একটি ব্লুপ্রিন্টের মতো কাজ করে যা বিভিন্ন ক্লাসকে একটি নির্দিষ্ট উপায়ে আচরণ করতে বাধ্য করে। 
যে ক্লাস একটি ইন্টারফেস ইমপ্লিমেন্ট (implement) করে, তাকে অবশ্যই ইন্টারফেসে ঘোষিত সমস্ত মেথডের বাস্তবায়ন প্রদান করতে হয়। এটি বিভিন্ন ক্লাসের মধ্যে সামঞ্জস্য এবং সহযোগিতা নিশ্চিত করে।

উদাহরণ: একটি Movable ইন্টারফেস হয়তো move() নামক একটি মেথড ঘোষণা করতে পারে। Car, Animal, এবং Robot ক্লাস এই ইন্টারফেস ইমপ্লিমেন্ট করলে, প্রত্যেকটিকেই তাদের নিজস্ব উপায়ে move() মেথডের বাস্তবায়ন করতে হবে।

অ্যাবস্ট্রাকশন (Abstraction): 
ইন্টারফেস বাস্তবায়নের বিশদ বিবরণ (implementation details) থেকে ব্যবহারকারীকে আলাদা করে রাখে। 
ব্যবহারকারী শুধুমাত্র ইন্টারফেসের মাধ্যমে সংজ্ঞায়িত আচরণ সম্পর্কে জানে, কীভাবে সেই আচরণ বাস্তবায়িত হচ্ছে তা তার জানার প্রয়োজন নেই। এটি সিস্টেমের জটিলতা কমায় এবং মডুলারিটি বাড়ায়।

উদাহরণ: একটি DatabaseConnection ইন্টারফেস connect(), query(), এবং disconnect() মেথড ঘোষণা করতে পারে।
বিভিন্ন ডেটাবেস (যেমন MySQL, PostgreSQL) এই ইন্টারফেস ইমপ্লিমেন্ট করতে পারে, কিন্তু অ্যাপ্লিকেশন কোড শুধুমাত্র DatabaseConnection ইন্টারফেসের মাধ্যমে ডেটাবেসের সাথে যোগাযোগ করে, নির্দিষ্ট ডেটাবেসের বাস্তবায়ন সম্পর্কে না জেনেও।

পলিমরফিজম (Polymorphism - বহুরূপতা): ই
ন্টারফেস ব্যবহার করে পলিমরফিজম অর্জন করা যায়। এর মাধ্যমে বিভিন্ন ক্লাসের অবজেক্টকে একটি সাধারণ ইন্টারফেস টাইপের মাধ্যমে ব্যবহার করা সম্ভব হয়। 
এটি কোডকে আরও নমনীয় এবং পরিবর্তনশীল করে তোলে।

উদাহরণ: যদি Car এবং Bike উভয়ই Movable ইন্টারফেস ইমপ্লিমেন্ট করে, তাহলে আমরা Movable টাইপের একটি ভেরিয়েবলে Car বা Bike এর অবজেক্ট রাখতে পারি এবং move() মেথড কল করতে পারি। 
কোন অবজেক্টের উপর move() কল করা হচ্ছে তার উপর ভিত্তি করে ভিন্ন ভিন্ন আচরণ প্রদর্শিত হবে।

কাপলিং কমানো (Reducing Coupling): ইন্টারফেস ব্যবহার করে বিভিন্ন কম্পোনেন্টের মধ্যে নির্ভরতা (dependency) কমানো যায়। 
একটি কম্পোনেন্ট যদি কোনো নির্দিষ্ট ক্লাসের উপর সরাসরি নির্ভরশীল না হয়ে একটি ইন্টারফেসের উপর নির্ভরশীল হয়, তাহলে ঐ ইন্টারফেস ইমপ্লিমেন্ট করে এমন যেকোনো ক্লাস ব্যবহার করা যেতে পারে। 
এর ফলে সিস্টেমের বিভিন্ন অংশ একে অপরের সাথে কম আবদ্ধ থাকে এবং পরিবর্তন করা সহজ হয়।

উদাহরণ: একটি ReportGenerator ক্লাস যদি DataSource নামক একটি ইন্টারফেসের উপর নির্ভর করে ডেটা লোড করার জন্য, 
তাহলে DataSource ইমপ্লিমেন্ট করে এমন যেকোনো ডেটা সোর্স (যেমন ফাইল, ডেটাবেস, API) ব্যবহার করা যেতে পারে ReportGenerator ক্লাসের কোড পরিবর্তন না করেই।

টেস্টিং (Testing): 
ইন্টারফেস ব্যবহার করে ইউনিট টেস্টিং করা সহজ হয়। 
ইন্টারফেসের উপর নির্ভর করা কম্পোনেন্টের জন্য মক (mock) বা স্টাব (stub) অবজেক্ট তৈরি করে অন্যান্য অংশের উপর নির্ভরতা ছাড়াই পরীক্ষা করা যায়।

সংক্ষেপে, ইন্টারফেস সফটওয়্যার ডিজাইনে একটি শক্তিশালী হাতিয়ার যা বিভিন্ন ক্লাসের মধ্যে একটি সুস্পষ্ট চুক্তি স্থাপন করে, অ্যাবস্ট্রাকশন এবং পলিমরফিজম অর্জন করতে সাহায্য করে, কম্পোনেন্টগুলোর মধ্যে কাপলিং কমায় 
এবং কোডের নমনীয়তা, রক্ষণাবেক্ষণযোগ্যতা এবং টেস্টেবিলিটি বৃদ্ধি করে।








-
